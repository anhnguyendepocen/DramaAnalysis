---
title: "R Basics"
author: "Nils Reiter, nils.reiter@ims.uni-stuttgart.de"
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: yes
  md_document:
    toc: yes
    variant: markdown_github
  rmarkdown::html_vignette:
    fig_height: 5
    fig_width: 6
bibliography: bibliography.bib
vignette: |
  %\VignetteIndexEntry{R Basics} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---

## Variables and Data types
Variables are names for things. Things need names in order to be acted upon. Things also have types. We first look at `character`, `logical` and `numeric`. The assigment operator `<-` assigns a thing (on the right side) to a variable (on the left).

```{r}
string <- "I am a character string."
number <- 5
logic <- TRUE
```

Entering a variable name or a thing literally and pressing enter in the console prints the content of the variable.

```{r}
logic
string
number
```

In general, variables are used as placeholders for things. Whenever we can use a thing, we can also use a variable (with content of the same type).

To find out which type a variable has (or a thing), we can use the function `class()`. Functions are recognizable by the round parentheses.

```{r}
class(logic)
class(string)
class(number)
```

## Operators

Mathematical operators (e.g., `+`) can be used to do math. Operators are written between the operands. The result of the operation is then printed in the output. 
```{r}
5+3
number - 2
```
We distinguish operator types: Artithemtic operators do the usual math stuff. See `help("+")` for a list of operators and details. Arithetmetic operators do stuff on numeric values and return numeric values.

In contrast, relational operators `help("<")` *compare* things. Consequently, they return a logical value, `TRUE` or `FALSE`. With the relational operator `==`, for instance, we can compare values.

```{r}
5 == 4
number == 5
"a" == "a"
```

Logical operators combine logical values and create new logical values.

The colon operator `:` generates sequences.

```{r}
5:10
100:1 # order is relevant

```

### "5" is not the same as 5

```{r}
"5" == 5
```

In order to be the same, two values need to be of the same type.

## Vectors and Lists
In R, singular values rarely exist. Instead, everything is part of a vector. In a vector, all components need to be of the same type. With the operator `[]`, we access individual components. 


```{r}
vec <- 1:10
vec[2]
class(vec)
class(vec[2])
```

We can do actions on entire vectors:

```{r}
vec <- 1:100
vec + 10 # every element gets increased by 10
(vec + 10) * 20 # ... and then multiplied by 20
vec / 2  # divide by 2
vec %% 2 # full-integer remainder
vec %% 2 == 0 # get a logical vector saying whether these numbers are even (dividable by 2)
```

The function `c()` can be used to combine vectors, `length()` returns the length of a vector (i.e., the number of components).

```{r}
vec1 <- 1:10
vec2 <- 30:100
length(vec1)
length(vec2)


vec3 <- c(vec1, vec2)
length(vec1) + length(vec2)
length(vec3)

```

The `[]`-operators allows access to more than one element:
```{r}
vec <- 1:100 # create a vector
vec[2:3] # extract the second and third element
vec[c(50,60,10)]  # extract elements 50, 60 and 10, in that order
vec[TRUE] # extract every element
vec[c(TRUE,FALSE)] # extract every second element
                   # Recycling!
vec[c(TRUE,FALSE,FALSE)] # extract every third element
vec[vec%%2==0] # extract every even element
```

In lists, the types of the components can be different and components can be named.

```{r}
# create a vector
v <- c(1,2,"a")
# vector will be of type "character". Why?
class(v)
# let's find out by printing the thing
v # numbers have been coerced into characters (!)

# create a list
l <- list(1,2,"a")
class(l) # is of class list
l
```

Huh? The list contains three list elements, they are represented in the output by `[[1]]`, `[[2]]`, and `[[3]]`. Each element is a vector of things, the first two vectors are numeric and the last one is a character-vector. 

In lists, we need `[[]]` to extract a single list element. Otherwise, we get a sub-list (possibly of length 1).
```{r}
l[1]
class(l[1])
l[[1]]
class(l[[1]])
class(l[[2]])
class(l[[3]])
```

Of course, we can extract multiple list elements at once:
```{r}
l[1:2]
l[c(1,3)]

# this gives an error message, because [[]] only extracts one list element
# l[[c(1,2)]]
```

### Named list elements

## Matrices and data frames

Vectors and lists are one-dimensional things. The two-dimensional corresponding things are matrices and data frames.

Matrices (`?matrix`) consist of values of the same type and are created with the `matrix()`-function. While creating, one needs to specify either the number of rows (`nrow`) or the number of columns (`ncol`) (or both).

```{r}
matrix(1:20,nrow=2)
matrix(1:20,ncol=2)
mat <- matrix(1:50,ncol=4)
mat
class(mat)
```

Matrix cells are access with the `[]`-operator. This time, it needs to contain two values (for row and column, in this order).

```{r}
mat
mat[3,2] # the element in row 3 and column 2

# again, we can use vectors as indices to access more than one row or column at once. In this example, we access rows 9 to 11 and column 2 (i.e., this returns a vector)
mat[9:11,2]
class(mat[9:11,2])

# using the same technique, we extract a sub-matrix
mat[9:11,1:3]
class(mat[9:11,1:3])
```

Matrices can have named rows and columns. Names must be character strings.

```{r}
colnames(mat) <- c("Spalte 1", "Zweite Spalte", "3. Spalte", "Spalte Nr. 4")
mat
```

Dataframes are similar to lists: They can contain columns of different types (and they are used extensively in data analysis).

```{r}
df <- data.frame(corpus=c("tg"), # recycling
                 drama=c("rksp.0","vndf.0"),
                 figure=c("Emilia","Julia"),
                 numberOfWords=c(20,10))
# access one (named) column
df$figure
# access one cell 
df[2,"figure"]
# or
df$figure[2]
```

## Functions

We have used a number of functions before: `class()`, `matrix()`, etc. Functions are things that can be executed. Functions are defined similarly to other variables (at least on the left side):
```{r}
func <- function(x,y) {
  # code goes here
  # the last thing gets returned
  x + y
}
```

`function` is a special keyword that indicates that this is a function definition. The round parentheses `()` represent the argument list, and the curly braces `{}` contain the body of the function, i.e., the code that gets executed when the function is called.

When defining functions, the time when the code is actually executed is different than the time when the code is written. You define code to be executed later (maybe under different circumstances). 

Functions can take **arguments**. These need to be *defined* in round braces when defining the function. The caller of the function is later responsible to provide values for these arguments.

Functions have a return **value**: This is the value that the caller of the function gets back. In R, the result of the last statement in the function body gets returned. In the above case, this is the sum of the two arguments.

Once defined, the function can be called like any other function, and we see the return value printed below.
```{r}
func(5,1)
func(5,2)
```

While defining a function, it is often useful to define default argument values. These values are used, when the caller of the function does not specify a value.

This function returns the sum of x and a power of y. By default, we use the power of 2, but the caller can specify any other value.
```{r}
func <- function(x,y,n=2) {
  x+y^n
}
func(5,1) # 6, because 1^2 is 1
func(5,2)
func(5,2,n=1) # disable the power
func(5,2,n=1000) # go crazy
```

## Text analysis
In general, we follow the tidy text paradigm (described [here](http://tidytextmining.com), for instance). The general idea is to represent text token-wise, as a table. Each token in a text is represented as one row in a data.frame. Token-based annotations (e.g., part of speech) can easily be stored on additional columns. Annotations that span multiple tokens (e.g., the speaker of a sentence) can also be stored in additional columns.